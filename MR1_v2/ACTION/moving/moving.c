#include "main.h"
#include "path.h"

#define THRESHOLD_VALUE 1


PLANNING_PATH *NOW_PATH;  // 当前路径的指针(需确保指向某个路径再进入路径跟踪函数）
u32 PATH_POINT_COUNTER = 1;     // 用于遍历路径上的离散点的变量
u32 PATH_POINT_SUM = 0;         // 当前路径离散点的总数
MOVING_BETWEEN_2PTS_INFO MOVING_BETWEEN_2PTS_INFO_DATA;
PID MOVING_YAW_PID;

float Vpath = 0,Vpath_before = 200;
float threshold;


// 实现机器人的移动功能
void moving_action_task(void)
{
	// 机器人处于移动状态
	if(MOVING_STATE == MOVING_GOING)
	{
		// 选择机器人当前的移动路径
		switch(NOW_STATE)
		{
			case MOVING_URTUU_TO_RZ:
			{
				PATH_POINT_SUM = (u32)(sizeof(URTUU_TO_RZ_PATH)/sizeof(URTUU_TO_RZ_PATH[0])); 
				NOW_PATH = URTUU_TO_RZ_PATH;
			}
			break;
			case MOVING_LINE1_TO_RZ:
			{
				PATH_POINT_SUM = (u32)(sizeof(LINE1_TO_RZ_PATH)/sizeof(LINE1_TO_RZ_PATH[0])); 
				NOW_PATH = LINE1_TO_RZ_PATH;
			}
			break;
			case MOVING_RZ_TO_S1:
			{
				PATH_POINT_SUM = (u32)(sizeof(RZ_TO_S1_PATH)/sizeof(RZ_TO_S1_PATH[0])); 
				NOW_PATH = RZ_TO_S1_PATH;
			}
			break;
			case MOVING_LINE1_TO_S1:
			{
				PATH_POINT_SUM = (u32)(sizeof(LINE1_TO_S1_PATH)/sizeof(LINE1_TO_S1_PATH[0])); 
				NOW_PATH = LINE1_TO_S1_PATH;
			}
			break;
			case MOVING_LINE1_TO_S2:
			{
				PATH_POINT_SUM = (u32)(sizeof(LINE1_TO_S2_PATH)/sizeof(LINE1_TO_S2_PATH[0])); 
				NOW_PATH = LINE1_TO_S2_PATH;
			}
			break;
			case MOVING_LINE1_TO_S3:
			{
				PATH_POINT_SUM = (u32)(sizeof(LINE1_TO_S3_PATH)/sizeof(LINE1_TO_S3_PATH[0])); 
				NOW_PATH = LINE1_TO_S3_PATH;
			}
			break;
			case MOVING_S1_TO_PZ:
			{
				PATH_POINT_SUM = (u32)(sizeof(S1_TO_PZ_PATH)/sizeof(S1_TO_PZ_PATH[0])); 
				NOW_PATH = S1_TO_PZ_PATH;
			}
			break;
			case MOVING_PZ_TO_TZ:
			{
				PATH_POINT_SUM = (u32)(sizeof(PZ_TO_TZ_PATH)/sizeof(PZ_TO_TZ_PATH[0])); 
				NOW_PATH = PZ_TO_TZ_PATH;
			}
			break;
			case MOVING_S1_TO_TZ:
			{
				PATH_POINT_SUM = (u32)(sizeof(S1_TO_TZ_PATH)/sizeof(S1_TO_TZ_PATH[0])); 
				NOW_PATH = S1_TO_TZ_PATH;
			}
			break;
			case MOVING_S2_TO_TZ:
			{
				PATH_POINT_SUM = (u32)(sizeof(S2_TO_TZ_PATH)/sizeof(S2_TO_TZ_PATH[0])); 
				NOW_PATH = S2_TO_TZ_PATH;
			}
			break;
			case MOVING_S3_TO_TZ:
			{
				PATH_POINT_SUM = (u32)(sizeof(S3_TO_TZ_PATH)/sizeof(S3_TO_TZ_PATH[0])); 
				NOW_PATH = S3_TO_TZ_PATH;
			}
			break;
			case MOVING_TZ_TO_S1:
			{
				PATH_POINT_SUM = (u32)(sizeof(TZ_TO_S1_PATH)/sizeof(TZ_TO_S1_PATH[0])); 
				NOW_PATH = TZ_TO_S1_PATH;
			}
			break;
			case MOVING_TZ_TO_S2:
			{
				PATH_POINT_SUM = (u32)(sizeof(TZ_TO_S2_PATH)/sizeof(TZ_TO_S2_PATH[0])); 
				NOW_PATH = TZ_TO_S2_PATH;
			}
			break;
			case MOVING_TZ_TO_S3:
			{
				PATH_POINT_SUM = (u32)(sizeof(TZ_TO_S3_PATH)/sizeof(TZ_TO_S3_PATH[0])); 
				NOW_PATH = TZ_TO_S3_PATH;
			}
			break;
		}
		
		moving_path_tracking();
	}
	
	//机器人处于其他三种状态
	else
	{
		ROBOT_TARGET_VELOCITY_DATA.Vx_RPM = 0;
		ROBOT_TARGET_VELOCITY_DATA.Vy_RPM = 0;
		ROBOT_TARGET_VELOCITY_DATA.W_RPM = 0;
		MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY = 0;  // 清除即时速度信息
	}
}


// 移动功能初始化
void moving_init(void)
{
	// 初始化PID参数
	PID_parameter_init(&MOVING_YAW_PID, 40.0, 0, 1.0, 500.0, 500.0);
	
	// 可加坐标微调补偿
}


// 路径跟踪
void moving_path_tracking(void)
{
	// 计算差距
	MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS = sqrt((NOW_PATH[PATH_POINT_COUNTER].x - NOW_PATH[PATH_POINT_COUNTER-1].x) * 
																												(NOW_PATH[PATH_POINT_COUNTER].x - NOW_PATH[PATH_POINT_COUNTER-1].x) +
																												(NOW_PATH[PATH_POINT_COUNTER].y - NOW_PATH[PATH_POINT_COUNTER-1].y) * 
																												(NOW_PATH[PATH_POINT_COUNTER].y - NOW_PATH[PATH_POINT_COUNTER-1].y));
	
	
	MOVING_BETWEEN_2PTS_INFO_DATA.X_GAP = NOW_PATH[PATH_POINT_COUNTER].x - ROBOT_REAL_POS_DATA.X_POS;
	MOVING_BETWEEN_2PTS_INFO_DATA.Y_GAP = NOW_PATH[PATH_POINT_COUNTER].y - ROBOT_REAL_POS_DATA.Y_POS;
	
	MOVING_BETWEEN_2PTS_INFO_DATA.GAP_DIS = sqrt(MOVING_BETWEEN_2PTS_INFO_DATA.X_GAP * MOVING_BETWEEN_2PTS_INFO_DATA.X_GAP +
																							 MOVING_BETWEEN_2PTS_INFO_DATA.Y_GAP * MOVING_BETWEEN_2PTS_INFO_DATA.Y_GAP);
	if(MOVING_BETWEEN_2PTS_INFO_DATA.GAP_DIS > MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS)  // 防止计算已移动距离出错
	{
		MOVING_BETWEEN_2PTS_INFO_DATA.GAP_DIS = MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS;
	}
	MOVING_BETWEEN_2PTS_INFO_DATA.MOVED_DIS = absolute(MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS -  MOVING_BETWEEN_2PTS_INFO_DATA.GAP_DIS);
	MOVING_BETWEEN_2PTS_INFO_DATA.YAW_GAP = NOW_PATH[PATH_POINT_COUNTER].yaw - ROBOT_REAL_POS_DATA.YAW_POS;
	
	// 判断机器人是否到达离散点且符合预定姿态
	if(PATH_POINT_COUNTER < PATH_POINT_SUM-1)  // 若不是最后一个点
	{
		
		
		#if THRESHOLD_VALUE
		//threshold = (MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS)/3;
		if(MOVING_BETWEEN_2PTS_INFO_DATA.GAP_DIS <= PASS_POINT_REACH_THRESHOLD_POS)//阈值			PASS_POINT_REACH_THRESHOLD_POS（自己确定的阈值）
			{
				PATH_POINT_COUNTER ++;  // 切换到下一个离散点
				//Vpath_before = Vpath;
				return;
			}
		#endif
			
	}
	else  // 若为最后一个点
	{
		if(MOVING_BETWEEN_2PTS_INFO_DATA.GAP_DIS <= STOP_POINT_REACH_THRESHOLD_POS &&
			 absolute(MOVING_BETWEEN_2PTS_INFO_DATA.YAW_GAP) <= STOP_POINT_REACH_THRESHOLD_YAW)
		{
			PATH_POINT_COUNTER = 1;  // 遍历变量置1
			MOVING_STATE = MOVING_ARRIVED;  // 切换移动状态
			return;
		}
	}
	
	// 根据规划速度与路程信息计算实时速度
	if((PATH_POINT_COUNTER == PATH_POINT_SUM-1) && (MOVING_BETWEEN_2PTS_INFO_DATA.GAP_DIS <= STOP_POINT_REACH_THRESHOLD_POS))  //若为最后一个点且到达离散点但姿态不符合
	{
		// 让机器人停止移动，只在下面进行偏航角调整
		ROBOT_TARGET_VELOCITY_DATA.Vx_RPM = 0;
		ROBOT_TARGET_VELOCITY_DATA.Vy_RPM = 0;
	}
	else  // 若是其他情况
	{
		
		//Vpath = (2*MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS/3)/0.06;
		/*
		if(PATH_POINT_COUNTER >= 62 )
		{	
			Vpath = 600;
			
		}
		if(Vpath >= 1500)Vpath=1600;
		
		MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY = Vpath;
		
		MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY  =  Vpath_before +
																											(MOVING_BETWEEN_2PTS_INFO_DATA.MOVED_DIS / MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS) * 
																											(Vpath - Vpath_before);
		if(PATH_POINT_COUNTER == 63)MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY  = 0;
		*/
		
		// 计算即时速度
		MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY = NOW_PATH[PATH_POINT_COUNTER-1].V +
																											(MOVING_BETWEEN_2PTS_INFO_DATA.MOVED_DIS / MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS) * 
																											(NOW_PATH[PATH_POINT_COUNTER].V - NOW_PATH[PATH_POINT_COUNTER-1].V);
	
		
		
		
		
			///梯形速度
//		if(MOVING_BETWEEN_2PTS_INFO_DATA.MOVED_DIS<MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS0*0.1)
//		{
//			MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY = NOW_PATH[PATH_POINT_COUNTER-1].V +
//																										(2*MOVING_BETWEEN_2PTS_INFO_DATA.MOVED_DIS / MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS) * 
//																										(NOW_PATH[PATH_POINT_COUNTER].V - NOW_PATH[PATH_POINT_COUNTER-1].V);
//		}
//		else if((MOVING_BETWEEN_2PTS_INFO_DATA.MOVED_DIS>=MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS*0.1)&&(MOVING_BETWEEN_2PTS_INFO_DATA.MOVED_DIS<=0.6*MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS))
//		{
//			MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY = NOW_PATH[PATH_POINT_COUNTER].V;
//		}
//		else if(MOVING_BETWEEN_2PTS_INFO_DATA.MOVED_DIS>0.6*MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS)
//		{
//			MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY = NOW_PATH[PATH_POINT_COUNTER].V + 
//							((MOVING_BETWEEN_2PTS_INFO_DATA.MOVED_DIS - MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS*0.6)  / MOVING_BETWEEN_2PTS_INFO_DATA.BETWEEN_2PTS_DIS*0.4) * 
//							(NOW_PATH[PATH_POINT_COUNTER].V - NOW_PATH[PATH_POINT_COUNTER].V/2);
//		}
//		else 
//		{
//			MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY = MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY;
//		}
		///梯形速度
		
		
		// 将即时速度进行分解
		ROBOT_TARGET_VELOCITY_DATA.Vx_RPM = (MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY * MM_PER_SEC_TO_RPM) *
																				 MOVING_BETWEEN_2PTS_INFO_DATA.X_GAP / MOVING_BETWEEN_2PTS_INFO_DATA.GAP_DIS;
		ROBOT_TARGET_VELOCITY_DATA.Vy_RPM = (MOVING_BETWEEN_2PTS_INFO_DATA.IMMEDIATE_VELOCITY * MM_PER_SEC_TO_RPM) *
																				 MOVING_BETWEEN_2PTS_INFO_DATA.Y_GAP / MOVING_BETWEEN_2PTS_INFO_DATA.GAP_DIS;

	}
	
	// 利用PID设置角速度
	if((PATH_POINT_COUNTER < PATH_POINT_SUM-1) && (absolute(MOVING_BETWEEN_2PTS_INFO_DATA.YAW_GAP) <= PASS_POINT_REACH_THRESHOLD_YAW) ||
		 (PATH_POINT_COUNTER == PATH_POINT_SUM-1) && (absolute(MOVING_BETWEEN_2PTS_INFO_DATA.YAW_GAP) <= STOP_POINT_REACH_THRESHOLD_YAW))  // 若符合离散点的偏航角
	{
		ROBOT_TARGET_VELOCITY_DATA.W_RPM = 0;  // 不作调整
	}
	else
	{
		// 利用PID进行调整
		PID_position_PID_calculation(&MOVING_YAW_PID, ROBOT_REAL_POS_DATA.YAW_POS, NOW_PATH[PATH_POINT_COUNTER].yaw);
		ROBOT_TARGET_VELOCITY_DATA.W_RPM = MOVING_YAW_PID.output;
	}
}





